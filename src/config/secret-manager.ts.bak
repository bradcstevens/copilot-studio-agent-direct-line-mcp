/**
 * Secret management service with Key Vault and environment variable fallback
 * Provides unified interface for retrieving secrets from multiple sources
 */

import { KeyVaultManager, createKeyVaultManager, type KeyVaultConfig } from '../services/key-vault-manager.js';
import type { EnvConfig } from './env.schema.js';

/**
 * Secret source priority
 */
export type SecretSource = 'key-vault' | 'environment' | 'default';

/**
 * Secret retrieval result
 */
export interface SecretResult {
  value: string;
  source: SecretSource;
}

/**
 * Secret manager configuration
 */
export interface SecretManagerConfig {
  /**
   * Environment configuration
   */
  env: EnvConfig;

  /**
   * Enable Key Vault integration
   * Default: true in production, false otherwise
   */
  enableKeyVault?: boolean;

  /**
   * Fallback to environment variables if Key Vault fails
   * Default: true
   */
  fallbackToEnv?: boolean;
}

/**
 * Well-known secret names mapped to environment variables
 */
export const SECRET_MAPPINGS = {
  // Direct Line
  'direct-line-secret': 'DIRECT_LINE_SECRET',

  // Azure Entra ID
  'azure-client-id': 'AZURE_CLIENT_ID',
  'azure-client-secret': 'AZURE_CLIENT_SECRET',
  'azure-tenant-id': 'AZURE_TENANT_ID',

  // Session & Security
  'session-secret': 'SESSION_SECRET',
  'session-encryption-key': 'SESSION_ENCRYPTION_KEY',

  // Redis
  'redis-password': 'REDIS_PASSWORD',
  'redis-url': 'REDIS_URL',

  // API Keys (if needed)
  'api-key': 'API_KEY',
  'webhook-secret': 'WEBHOOK_SECRET',
} as const;

/**
 * Secret Manager - Manages secrets with Key Vault and environment variable fallback
 */
export class SecretManager {
  private keyVaultManager?: KeyVaultManager;
  private config: Required<SecretManagerConfig>;
  private env: EnvConfig;

  /**
   * Create a new secret manager
   * @param config - Secret manager configuration
   */
  constructor(config: SecretManagerConfig) {
    this.env = config.env;
    this.config = {
      env: config.env,
      enableKeyVault: config.enableKeyVault !== false && this.env.NODE_ENV === 'production',
      fallbackToEnv: config.fallbackToEnv !== false,
    };

    // Initialize Key Vault if enabled and configured
    if (this.config.enableKeyVault && this.env.KEY_VAULT_URL) {
      try {
        const keyVaultConfig: KeyVaultConfig = {
          vaultUrl: this.env.KEY_VAULT_URL,
          cacheEnabled: this.env.KEY_VAULT_CACHE_ENABLED,
          cacheTTL: this.env.KEY_VAULT_CACHE_TTL * 1000, // Convert seconds to milliseconds
        };

        // Use service principal in development if credentials are provided
        if (this.env.NODE_ENV !== 'production' && this.env.AZURE_CLIENT_ID && this.env.AZURE_CLIENT_SECRET && this.env.AZURE_TENANT_ID) {
          keyVaultConfig.useServicePrincipal = true;
          keyVaultConfig.clientId = this.env.AZURE_CLIENT_ID;
          keyVaultConfig.clientSecret = this.env.AZURE_CLIENT_SECRET;
          keyVaultConfig.tenantId = this.env.AZURE_TENANT_ID;
        }

        this.keyVaultManager = createKeyVaultManager(keyVaultConfig);
        console.log('[SecretManager] Key Vault integration enabled');

        // Start cache cleanup
        if (this.env.KEY_VAULT_CACHE_ENABLED) {
          this.keyVaultManager.startCacheCleanup();
        }
      } catch (error) {
        console.error('[SecretManager] Failed to initialize Key Vault:', error);
        if (!this.config.fallbackToEnv) {
          throw error;
        }
        console.warn('[SecretManager] Falling back to environment variables');
      }
    } else {
      console.log('[SecretManager] Using environment variables for secrets');
    }
  }

  /**
   * Get a secret by name
   * Tries Key Vault first, then falls back to environment variables
   * @param secretName - Name of the secret (Key Vault name or environment variable name)
   * @param options - Retrieval options
   * @returns Secret value and source
   */
  async getSecret(
    secretName: string,
    options?: {
      required?: boolean;
      defaultValue?: string;
      version?: string;
    }
  ): Promise<SecretResult> {
    const required = options?.required !== false;
    const defaultValue = options?.defaultValue;
    const version = options?.version;

    try {
      // Try Key Vault first if enabled
      if (this.keyVaultManager) {
        try {
          const value = await this.keyVaultManager.getSecret(secretName, version);
          return { value, source: 'key-vault' };
        } catch (error) {
          console.warn(`[SecretManager] Failed to get secret from Key Vault: ${secretName}`, error);

          if (!this.config.fallbackToEnv) {
            throw error;
          }
        }
      }

      // Fallback to environment variables
      const envVarName = this.getEnvVarName(secretName);
      const envValue = process.env[envVarName];

      if (envValue) {
        return { value: envValue, source: 'environment' };
      }

      // Try direct environment variable access if mapping didn't work
      const directEnvValue = process.env[secretName];
      if (directEnvValue) {
        return { value: directEnvValue, source: 'environment' };
      }

      // Use default value if provided
      if (defaultValue !== undefined) {
        return { value: defaultValue, source: 'default' };
      }

      // Secret not found
      if (required) {
        throw new Error(`Required secret not found: ${secretName}`);
      }

      throw new Error(`Secret not found: ${secretName}`);
    } catch (error) {
      console.error(`[SecretManager] Failed to get secret ${secretName}:`, error);
      throw error;
    }
  }

  /**
   * Get Direct Line secret
   * @returns Direct Line secret
   */
  async getDirectLineSecret(): Promise<string> {
    // Direct Line secret is already in env config, but might be in Key Vault in production
    if (this.keyVaultManager) {
      try {
        const result = await this.getSecret('direct-line-secret');
        return result.value;
      } catch {
        // Fall through to env
      }
    }
    return this.env.DIRECT_LINE_SECRET;
  }

  /**
   * Get Azure client secret
   * @returns Azure client secret
   */
  async getAzureClientSecret(): Promise<string | undefined> {
    if (!this.env.AZURE_CLIENT_SECRET && !this.keyVaultManager) {
      return undefined;
    }

    if (this.keyVaultManager) {
      try {
        const result = await this.getSecret('azure-client-secret', { required: false });
        return result.value;
      } catch {
        // Fall through to env
      }
    }

    return this.env.AZURE_CLIENT_SECRET;
  }

  /**
   * Get session secret
   * @returns Session secret
   */
  async getSessionSecret(): Promise<string> {
    const result = await this.getSecret('session-secret', {
      defaultValue: 'mcp-session-secret-change-in-production',
    });

    if (result.source === 'default' && this.env.NODE_ENV === 'production') {
      console.warn('[SecretManager] WARNING: Using default session secret in production!');
    }

    return result.value;
  }

  /**
   * Get Redis password
   * @returns Redis password
   */
  async getRedisPassword(): Promise<string | undefined> {
    if (this.env.SESSION_STORAGE_TYPE !== 'redis') {
      return undefined;
    }

    try {
      const result = await this.getSecret('redis-password', { required: false });
      return result.value;
    } catch {
      return undefined;
    }
  }

  /**
   * Set a secret (Key Vault only)
   * @param secretName - Name of the secret
   * @param value - Secret value
   * @param contentType - Optional content type
   */
  async setSecret(secretName: string, value: string, contentType?: string): Promise<void> {
    if (!this.keyVaultManager) {
      throw new Error('Key Vault is not enabled. Cannot set secrets.');
    }

    await this.keyVaultManager.setSecret(secretName, value, contentType);
  }

  /**
   * Rotate a secret (Key Vault only)
   * @param secretName - Name of the secret
   * @param newValue - New secret value
   * @param contentType - Optional content type
   */
  async rotateSecret(secretName: string, newValue: string, contentType?: string): Promise<void> {
    if (!this.keyVaultManager) {
      throw new Error('Key Vault is not enabled. Cannot rotate secrets.');
    }

    await this.keyVaultManager.rotateSecret(secretName, newValue, contentType);
  }

  /**
   * Check if Key Vault is enabled
   * @returns True if Key Vault is enabled
   */
  isKeyVaultEnabled(): boolean {
    return !!this.keyVaultManager;
  }

  /**
   * Get Key Vault manager (if enabled)
   * @returns Key Vault manager or undefined
   */
  getKeyVaultManager(): KeyVaultManager | undefined {
    return this.keyVaultManager;
  }

  /**
   * Get cache statistics (if Key Vault is enabled)
   */
  getCacheStats(): ReturnType<KeyVaultManager['getCacheStats']> | null {
    if (!this.keyVaultManager) {
      return null;
    }
    return this.keyVaultManager.getCacheStats();
  }

  /**
   * Clear Key Vault cache
   */
  clearCache(): void {
    if (this.keyVaultManager) {
      this.keyVaultManager.clearCache();
    }
  }

  /**
   * Get environment variable name from secret name
   * @param secretName - Secret name
   * @returns Environment variable name
   */
  private getEnvVarName(secretName: string): string {
    // Check if there's a mapping
    const mapping = SECRET_MAPPINGS[secretName as keyof typeof SECRET_MAPPINGS];
    if (mapping) {
      return mapping;
    }

    // Convert kebab-case to UPPER_SNAKE_CASE
    return secretName.replace(/-/g, '_').toUpperCase();
  }
}

/**
 * Create a secret manager instance
 * @param config - Secret manager configuration
 * @returns Secret manager
 */
export function createSecretManager(config: SecretManagerConfig): SecretManager {
  return new SecretManager(config);
}

/**
 * Singleton secret manager instance
 */
let defaultSecretManager: SecretManager | null = null;

/**
 * Get or create the default secret manager instance
 * @param config - Secret manager configuration (required on first call)
 * @returns Secret manager
 */
export function getSecretManager(config?: SecretManagerConfig): SecretManager {
  if (!defaultSecretManager) {
    if (!config) {
      throw new Error('Secret manager configuration is required for first initialization');
    }
    defaultSecretManager = new SecretManager(config);
  }
  return defaultSecretManager;
}

/**
 * Reset the default secret manager (useful for testing)
 */
export function resetSecretManager(): void {
  defaultSecretManager = null;
}
