/**
 * Environment-specific configuration management system
 * Supports different storage backends and authentication based on deployment environment
 */

import { getEnv, type EnvConfig } from './env.js';
import { SecretManager, createSecretManager } from './secret-manager.js';
import type { RedisClientType } from 'redis';

/**
 * Storage backend type
 */
export type StorageBackend = 'memory' | 'redis';

/**
 * Authentication mode
 */
export type AuthMode = 'none' | 'basic' | 'certificate';

/**
 * Environment-specific configuration
 */
export interface EnvironmentConfig {
  /**
   * Environment name
   */
  environment: 'development' | 'staging' | 'production';

  /**
   * Storage backend to use
   */
  storageBackend: StorageBackend;

  /**
   * Authentication mode
   */
  authMode: AuthMode;

  /**
   * Redis configuration (if using Redis storage)
   */
  redis?: {
    url: string;
    tlsEnabled: boolean;
    certificateAuth: boolean;
    maxRetries: number;
    retryDelay: number;
  };

  /**
   * Security settings
   */
  security: {
    enforceHttps: boolean;
    requireCertificates: boolean;
    sessionTimeout: number;
    maxSessionsPerUser: number;
  };

  /**
   * Feature flags
   */
  features: {
    keyVaultEnabled: boolean;
    rateLimitingEnabled: boolean;
    auditLoggingEnabled: boolean;
    metricsEnabled: boolean;
  };
}

/**
 * Configuration loading strategy
 */
export type ConfigSource = 'key-vault' | 'environment' | 'defaults';

/**
 * Configuration value with source tracking
 */
export interface ConfigValue<T> {
  value: T;
  source: ConfigSource;
  loadedAt: Date;
}

/**
 * Configuration Manager
 * Manages environment-specific configuration with hierarchical loading
 */
export class ConfigurationManager {
  private env: EnvConfig;
  private secretManager: SecretManager;
  private config: EnvironmentConfig;
  private configValues: Map<string, ConfigValue<any>> = new Map();
  private redisClient?: RedisClientType;

  /**
   * Create a new configuration manager
   * @param env - Environment configuration (optional, loads from process.env if not provided)
   */
  constructor(env?: EnvConfig) {
    // Load environment configuration
    this.env = env || getEnv();

    // Initialize secret manager
    this.secretManager = createSecretManager({
      env: this.env,
      enableKeyVault: this.env.NODE_ENV === 'production',
      fallbackToEnv: true,
    });

    // Build environment-specific configuration
    this.config = this.buildEnvironmentConfig();

    console.log(`[ConfigurationManager] Initialized for environment: ${this.config.environment}`);
    console.log(`[ConfigurationManager] Storage backend: ${this.config.storageBackend}`);
    console.log(`[ConfigurationManager] Authentication mode: ${this.config.authMode}`);
  }

  /**
   * Build environment-specific configuration
   */
  private buildEnvironmentConfig(): EnvironmentConfig {
    const nodeEnv = this.env.NODE_ENV;

    // Base configuration
    const config: EnvironmentConfig = {
      environment: nodeEnv,
      storageBackend: this.env.SESSION_STORAGE_TYPE,
      authMode: this.determineAuthMode(),
      security: {
        enforceHttps: nodeEnv === 'production',
        requireCertificates: nodeEnv === 'production' && this.env.REDIS_TLS_ENABLED,
        sessionTimeout: 24 * 60 * 60 * 1000, // 24 hours
        maxSessionsPerUser: 5,
      },
      features: {
        keyVaultEnabled: !!this.env.KEY_VAULT_URL,
        rateLimitingEnabled: nodeEnv !== 'development',
        auditLoggingEnabled: nodeEnv === 'production',
        metricsEnabled: nodeEnv !== 'development',
      },
    };

    // Redis configuration (if using Redis)
    if (config.storageBackend === 'redis' && this.env.REDIS_URL) {
      config.redis = {
        url: this.env.REDIS_URL,
        tlsEnabled: this.env.REDIS_TLS_ENABLED,
        certificateAuth: nodeEnv === 'production' && this.env.REDIS_TLS_ENABLED,
        maxRetries: nodeEnv === 'production' ? 10 : 3,
        retryDelay: nodeEnv === 'production' ? 1000 : 500,
      };
    }

    return config;
  }

  /**
   * Determine authentication mode based on environment
   */
  private determineAuthMode(): AuthMode {
    const nodeEnv = this.env.NODE_ENV;

    // Production requires certificate-based auth if Redis TLS is enabled
    if (nodeEnv === 'production' && this.env.REDIS_TLS_ENABLED) {
      return 'certificate';
    }

    // Staging uses basic auth
    if (nodeEnv === 'staging') {
      return 'basic';
    }

    // Development uses no auth (memory storage)
    return 'none';
  }

  /**
   * Get a configuration value with hierarchical loading
   * Priority: Key Vault -> Environment Variables -> Defaults
   * @param key - Configuration key
   * @param defaultValue - Default value if not found
   * @returns Configuration value with source
   */
  async getConfigValue<T>(key: string, defaultValue?: T): Promise<ConfigValue<T>> {
    // Check cache first
    const cached = this.configValues.get(key);
    if (cached) {
      return cached as ConfigValue<T>;
    }

    let value: T | undefined;
    let source: ConfigSource = 'defaults';

    // Try Key Vault first (if enabled)
    if (this.secretManager.isKeyVaultEnabled()) {
      try {
        const secret = await this.secretManager.getSecret(key, { required: false });
        value = secret.value as T;
        source = 'key-vault';
      } catch {
        // Fall through to next source
      }
    }

    // Try environment variables
    if (value === undefined) {
      const envValue = process.env[key];
      if (envValue !== undefined) {
        value = envValue as T;
        source = 'environment';
      }
    }

    // Use default value
    if (value === undefined) {
      value = defaultValue;
      source = 'defaults';
    }

    if (value === undefined) {
      throw new Error(`Configuration value not found and no default provided: ${key}`);
    }

    // Cache the value
    const configValue: ConfigValue<T> = {
      value,
      source,
      loadedAt: new Date(),
    };
    this.configValues.set(key, configValue);

    return configValue;
  }

  /**
   * Get environment configuration
   */
  getEnvironmentConfig(): EnvironmentConfig {
    return { ...this.config };
  }

  /**
   * Get environment variables
   */
  getEnv(): EnvConfig {
    return this.env;
  }

  /**
   * Get secret manager
   */
  getSecretManager(): SecretManager {
    return this.secretManager;
  }

  /**
   * Check if running in production
   */
  isProduction(): boolean {
    return this.config.environment === 'production';
  }

  /**
   * Check if running in staging
   */
  isStaging(): boolean {
    return this.config.environment === 'staging';
  }

  /**
   * Check if running in development
   */
  isDevelopment(): boolean {
    return this.config.environment === 'development';
  }

  /**
   * Get storage backend type
   */
  getStorageBackend(): StorageBackend {
    return this.config.storageBackend;
  }

  /**
   * Check if using Redis storage
   */
  isUsingRedis(): boolean {
    return this.config.storageBackend === 'redis';
  }

  /**
   * Check if using memory storage
   */
  isUsingMemory(): boolean {
    return this.config.storageBackend === 'memory';
  }

  /**
   * Get Redis configuration
   */
  getRedisConfig(): EnvironmentConfig['redis'] {
    if (!this.config.redis) {
      throw new Error('Redis is not configured');
    }
    return { ...this.config.redis };
  }

  /**
   * Initialize Redis client (if using Redis storage)
   * @returns Redis client or undefined
   */
  async initializeRedisClient(): Promise<RedisClientType | undefined> {
    if (!this.isUsingRedis()) {
      return undefined;
    }

    if (this.redisClient) {
      return this.redisClient;
    }

    const { createClient } = await import('redis');
    const redisConfig = this.getRedisConfig();

    console.log('[ConfigurationManager] Initializing Redis client');

    const clientOptions: any = {
      url: redisConfig!.url,
      socket: {
        reconnectStrategy: (retries: number) => {
          if (retries > redisConfig!.maxRetries) {
            console.error('[ConfigurationManager] Redis max retries exceeded');
            return new Error('Redis max retries exceeded');
          }
          const delay = Math.min(retries * redisConfig!.retryDelay, 30000);
          console.log(`[ConfigurationManager] Reconnecting to Redis in ${delay}ms (attempt ${retries})`);
          return delay;
        },
      },
    };

    // Add TLS configuration if enabled
    if (redisConfig!.tlsEnabled) {
      console.log('[ConfigurationManager] Enabling Redis TLS');
      clientOptions.socket.tls = true;

      // Add certificate authentication if required
      if (redisConfig!.certificateAuth) {
        console.log('[ConfigurationManager] Enabling Redis certificate authentication');
        // Certificate paths would be configured via environment variables
        // or loaded from Key Vault in production
        clientOptions.socket.cert = process.env.REDIS_CLIENT_CERT;
        clientOptions.socket.key = process.env.REDIS_CLIENT_KEY;
        clientOptions.socket.ca = process.env.REDIS_CA_CERT;
      }
    }

    this.redisClient = createClient(clientOptions) as RedisClientType;

    // Set up event handlers
    this.redisClient.on('error', (error) => {
      console.error('[ConfigurationManager] Redis error:', error);
    });

    this.redisClient.on('connect', () => {
      console.log('[ConfigurationManager] Redis connected');
    });

    this.redisClient.on('reconnecting', () => {
      console.log('[ConfigurationManager] Redis reconnecting');
    });

    this.redisClient.on('ready', () => {
      console.log('[ConfigurationManager] Redis ready');
    });

    // Connect to Redis
    await this.redisClient.connect();

    return this.redisClient;
  }

  /**
   * Get Redis client (must be initialized first)
   */
  getRedisClient(): RedisClientType | undefined {
    return this.redisClient;
  }

  /**
   * Validate configuration for current environment
   * @throws Error if configuration is invalid
   */
  validateConfiguration(): void {
    console.log('[ConfigurationManager] Validating configuration');

    // Production-specific validations
    if (this.isProduction()) {
      // Require Key Vault in production
      if (!this.config.features.keyVaultEnabled) {
        throw new Error('Key Vault is required in production environment');
      }

      // Require Redis in production
      if (!this.isUsingRedis()) {
        console.warn('[ConfigurationManager] WARNING: Using memory storage in production is not recommended');
      }

      // Require TLS for Redis in production
      if (this.isUsingRedis() && !this.config.redis?.tlsEnabled) {
        throw new Error('Redis TLS must be enabled in production environment');
      }

      // Require OAuth credentials in production
      if (!this.env.AZURE_CLIENT_ID || !this.env.AZURE_CLIENT_SECRET || !this.env.AZURE_TENANT_ID) {
        throw new Error('Azure OAuth credentials are required in production environment');
      }

      // Require HTTPS redirect URI in production
      if (this.env.REDIRECT_URI && !this.env.REDIRECT_URI.startsWith('https://')) {
        const url = new URL(this.env.REDIRECT_URI);
        if (url.hostname !== 'localhost' && url.hostname !== '127.0.0.1') {
          throw new Error('REDIRECT_URI must use HTTPS in production (except localhost)');
        }
      }
    }

    // Redis-specific validations
    if (this.isUsingRedis()) {
      if (!this.env.REDIS_URL) {
        throw new Error('REDIS_URL is required when using Redis storage');
      }
    }

    console.log('[ConfigurationManager] Configuration validation passed');
  }

  /**
   * Hot-reload configuration from sources
   * Clears cache and reloads from Key Vault/environment
   */
  async reloadConfiguration(): Promise<void> {
    console.log('[ConfigurationManager] Reloading configuration');

    // Clear config cache
    this.configValues.clear();

    // Clear secret manager cache
    this.secretManager.clearCache();

    // Rebuild environment config
    this.config = this.buildEnvironmentConfig();

    console.log('[ConfigurationManager] Configuration reloaded');
  }

  /**
   * Get configuration summary for logging
   */
  getConfigurationSummary(): Record<string, any> {
    return {
      environment: this.config.environment,
      storageBackend: this.config.storageBackend,
      authMode: this.config.authMode,
      security: {
        enforceHttps: this.config.security.enforceHttps,
        requireCertificates: this.config.security.requireCertificates,
      },
      features: this.config.features,
      redis: this.config.redis ? {
        tlsEnabled: this.config.redis.tlsEnabled,
        certificateAuth: this.config.redis.certificateAuth,
      } : undefined,
    };
  }

  /**
   * Cleanup resources
   */
  async cleanup(): Promise<void> {
    console.log('[ConfigurationManager] Cleaning up');

    // Disconnect Redis if connected
    if (this.redisClient) {
      await this.redisClient.quit();
      this.redisClient = undefined;
    }

    // Clear caches
    this.configValues.clear();
    this.secretManager.clearCache();
  }
}

/**
 * Create a configuration manager instance
 * @param env - Optional environment configuration
 * @returns Configuration manager
 */
export function createConfigurationManager(env?: EnvConfig): ConfigurationManager {
  return new ConfigurationManager(env);
}

/**
 * Singleton configuration manager instance
 */
let defaultConfigManager: ConfigurationManager | null = null;

/**
 * Get or create the default configuration manager
 * @param env - Optional environment configuration (only used on first call)
 * @returns Configuration manager
 */
export function getConfigurationManager(env?: EnvConfig): ConfigurationManager {
  if (!defaultConfigManager) {
    defaultConfigManager = new ConfigurationManager(env);
  }
  return defaultConfigManager;
}

/**
 * Reset the default configuration manager (useful for testing)
 */
export function resetConfigurationManager(): void {
  defaultConfigManager = null;
}
