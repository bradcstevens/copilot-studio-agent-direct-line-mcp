/**
 * Azure Key Vault secret management service
 * Uses @azure/keyvault-secrets v4+ for production secret storage and retrieval
 */

import { SecretClient } from '@azure/keyvault-secrets';
import { DefaultAzureCredential, ClientSecretCredential } from '@azure/identity';

/**
 * Key Vault configuration
 */
export interface KeyVaultConfig {
  /**
   * Azure Key Vault URL (e.g., https://myvault.vault.azure.net)
   */
  vaultUrl: string;

  /**
   * Enable secret caching in memory
   * Default: true
   */
  cacheEnabled?: boolean;

  /**
   * Cache TTL in milliseconds
   * Default: 300000 (5 minutes)
   */
  cacheTTL?: number;

  /**
   * Use service principal authentication instead of managed identity
   * Only for development/testing - production should use managed identity
   */
  useServicePrincipal?: boolean;

  /**
   * Service principal tenant ID (if useServicePrincipal is true)
   */
  tenantId?: string;

  /**
   * Service principal client ID (if useServicePrincipal is true)
   */
  clientId?: string;

  /**
   * Service principal client secret (if useServicePrincipal is true)
   */
  clientSecret?: string;
}

/**
 * Cached secret entry
 */
interface CachedSecret {
  value: string;
  expiresAt: number;
}

/**
 * Secret metadata
 */
export interface SecretMetadata {
  name: string;
  version?: string;
  enabled: boolean;
  createdOn?: Date;
  updatedOn?: Date;
  expiresOn?: Date;
  contentType?: string;
}

/**
 * Key Vault Manager - Manages secrets in Azure Key Vault
 */
export class KeyVaultManager {
  private client: SecretClient;
  private config: Required<Omit<KeyVaultConfig, 'useServicePrincipal' | 'tenantId' | 'clientId' | 'clientSecret'>>;
  private cache: Map<string, CachedSecret> = new Map();

  /**
   * Create a new Key Vault manager
   * @param config - Key Vault configuration
   */
  constructor(config: KeyVaultConfig) {
    this.config = {
      vaultUrl: config.vaultUrl,
      cacheEnabled: config.cacheEnabled !== false,
      cacheTTL: config.cacheTTL || 300000, // Default 5 minutes
    };

    // Create credential based on configuration
    let credential;
    if (config.useServicePrincipal && config.tenantId && config.clientId && config.clientSecret) {
      // Use service principal for development/testing
      console.log('[KeyVaultManager] Using service principal authentication');
      credential = new ClientSecretCredential(
        config.tenantId,
        config.clientId,
        config.clientSecret
      );
    } else {
      // Use managed identity for production
      console.log('[KeyVaultManager] Using managed identity authentication');
      credential = new DefaultAzureCredential();
    }

    // Create Key Vault client
    this.client = new SecretClient(config.vaultUrl, credential);

    console.log(`[KeyVaultManager] Initialized with vault: ${config.vaultUrl}`);
  }

  /**
   * Get a secret from Key Vault
   * @param secretName - Name of the secret
   * @param version - Optional version of the secret (defaults to latest)
   * @returns Secret value
   */
  async getSecret(secretName: string, version?: string): Promise<string> {
    try {
      // Check cache first if enabled
      if (this.config.cacheEnabled && !version) {
        const cached = this.getCachedSecret(secretName);
        if (cached) {
          console.log(`[KeyVaultManager] Cache hit for secret: ${secretName}`);
          return cached;
        }
      }

      // Fetch from Key Vault
      console.log(`[KeyVaultManager] Fetching secret from Key Vault: ${secretName}${version ? ` (version: ${version})` : ''}`);
      const secret = await this.client.getSecret(secretName, { version });

      if (!secret.value) {
        throw new Error(`Secret ${secretName} has no value`);
      }

      // Cache the secret if enabled and no specific version requested
      if (this.config.cacheEnabled && !version) {
        this.cacheSecret(secretName, secret.value);
      }

      return secret.value;
    } catch (error) {
      console.error(`[KeyVaultManager] Failed to get secret ${secretName}:`, error);
      throw new Error(`Failed to retrieve secret ${secretName}: ${error instanceof Error ? error.message : error}`);
    }
  }

  /**
   * Set a secret in Key Vault
   * @param secretName - Name of the secret
   * @param value - Secret value
   * @param contentType - Optional content type (e.g., 'text/plain', 'application/json')
   * @returns Secret metadata
   */
  async setSecret(secretName: string, value: string, contentType?: string): Promise<SecretMetadata> {
    try {
      console.log(`[KeyVaultManager] Setting secret in Key Vault: ${secretName}`);

      const result = await this.client.setSecret(secretName, value, {
        contentType,
      });

      // Invalidate cache for this secret
      if (this.config.cacheEnabled) {
        this.invalidateCachedSecret(secretName);
      }

      return {
        name: result.name,
        version: result.properties.version,
        enabled: result.properties.enabled || false,
        createdOn: result.properties.createdOn,
        updatedOn: result.properties.updatedOn,
        expiresOn: result.properties.expiresOn,
        contentType: result.properties.contentType,
      };
    } catch (error) {
      console.error(`[KeyVaultManager] Failed to set secret ${secretName}:`, error);
      throw new Error(`Failed to set secret ${secretName}: ${error instanceof Error ? error.message : error}`);
    }
  }

  /**
   * Rotate a secret by creating a new version
   * @param secretName - Name of the secret
   * @param newValue - New secret value
   * @param contentType - Optional content type
   * @returns Secret metadata
   */
  async rotateSecret(secretName: string, newValue: string, contentType?: string): Promise<SecretMetadata> {
    try {
      console.log(`[KeyVaultManager] Rotating secret: ${secretName}`);

      // Set new value (creates new version)
      const result = await this.setSecret(secretName, newValue, contentType);

      console.log(`[KeyVaultManager] Secret rotated successfully: ${secretName} (new version: ${result.version})`);

      return result;
    } catch (error) {
      console.error(`[KeyVaultManager] Failed to rotate secret ${secretName}:`, error);
      throw new Error(`Failed to rotate secret ${secretName}: ${error instanceof Error ? error.message : error}`);
    }
  }

  /**
   * Delete a secret from Key Vault
   * @param secretName - Name of the secret
   */
  async deleteSecret(secretName: string): Promise<void> {
    try {
      console.log(`[KeyVaultManager] Deleting secret: ${secretName}`);

      await this.client.beginDeleteSecret(secretName);

      // Invalidate cache
      if (this.config.cacheEnabled) {
        this.invalidateCachedSecret(secretName);
      }

      console.log(`[KeyVaultManager] Secret deleted: ${secretName}`);
    } catch (error) {
      console.error(`[KeyVaultManager] Failed to delete secret ${secretName}:`, error);
      throw new Error(`Failed to delete secret ${secretName}: ${error instanceof Error ? error.message : error}`);
    }
  }

  /**
   * List all secret names in the vault
   * @returns Array of secret names
   */
  async listSecrets(): Promise<string[]> {
    try {
      console.log('[KeyVaultManager] Listing secrets');

      const secretNames: string[] = [];

      for await (const secretProperties of this.client.listPropertiesOfSecrets()) {
        secretNames.push(secretProperties.name);
      }

      console.log(`[KeyVaultManager] Found ${secretNames.length} secrets`);
      return secretNames;
    } catch (error) {
      console.error('[KeyVaultManager] Failed to list secrets:', error);
      throw new Error(`Failed to list secrets: ${error instanceof Error ? error.message : error}`);
    }
  }

  /**
   * Get secret metadata without retrieving the value
   * @param secretName - Name of the secret
   * @returns Secret metadata
   */
  async getSecretMetadata(secretName: string): Promise<SecretMetadata> {
    try {
      console.log(`[KeyVaultManager] Getting metadata for secret: ${secretName}`);

      const secret = await this.client.getSecret(secretName);

      return {
        name: secret.name,
        version: secret.properties.version,
        enabled: secret.properties.enabled || false,
        createdOn: secret.properties.createdOn,
        updatedOn: secret.properties.updatedOn,
        expiresOn: secret.properties.expiresOn,
        contentType: secret.properties.contentType,
      };
    } catch (error) {
      console.error(`[KeyVaultManager] Failed to get metadata for ${secretName}:`, error);
      throw new Error(`Failed to get secret metadata: ${error instanceof Error ? error.message : error}`);
    }
  }

  /**
   * Check if a secret exists
   * @param secretName - Name of the secret
   * @returns True if secret exists
   */
  async secretExists(secretName: string): Promise<boolean> {
    try {
      await this.client.getSecret(secretName);
      return true;
    } catch (error: any) {
      if (error.statusCode === 404) {
        return false;
      }
      throw error;
    }
  }

  /**
   * Get secret from cache
   * @param secretName - Name of the secret
   * @returns Cached secret value or null
   */
  private getCachedSecret(secretName: string): string | null {
    const cached = this.cache.get(secretName);

    if (!cached) {
      return null;
    }

    // Check if expired
    if (Date.now() >= cached.expiresAt) {
      this.cache.delete(secretName);
      console.log(`[KeyVaultManager] Cache expired for secret: ${secretName}`);
      return null;
    }

    return cached.value;
  }

  /**
   * Cache a secret
   * @param secretName - Name of the secret
   * @param value - Secret value
   */
  private cacheSecret(secretName: string, value: string): void {
    const expiresAt = Date.now() + this.config.cacheTTL;
    this.cache.set(secretName, { value, expiresAt });
    console.log(`[KeyVaultManager] Cached secret: ${secretName} (expires in ${this.config.cacheTTL}ms)`);
  }

  /**
   * Invalidate cached secret
   * @param secretName - Name of the secret
   */
  private invalidateCachedSecret(secretName: string): void {
    if (this.cache.delete(secretName)) {
      console.log(`[KeyVaultManager] Invalidated cache for secret: ${secretName}`);
    }
  }

  /**
   * Clear all cached secrets
   */
  clearCache(): void {
    const count = this.cache.size;
    this.cache.clear();
    console.log(`[KeyVaultManager] Cleared ${count} cached secrets`);
  }

  /**
   * Get cache statistics
   */
  getCacheStats(): {
    size: number;
    secrets: Array<{ name: string; expiresIn: number }>;
  } {
    const now = Date.now();
    const secrets = Array.from(this.cache.entries()).map(([name, cached]) => ({
      name,
      expiresIn: Math.max(0, cached.expiresAt - now),
    }));

    return {
      size: this.cache.size,
      secrets,
    };
  }

  /**
   * Cleanup expired cache entries
   */
  cleanupCache(): void {
    const now = Date.now();
    let cleaned = 0;

    for (const [name, cached] of this.cache.entries()) {
      if (now >= cached.expiresAt) {
        this.cache.delete(name);
        cleaned++;
      }
    }

    if (cleaned > 0) {
      console.log(`[KeyVaultManager] Cleaned up ${cleaned} expired cache entries`);
    }
  }

  /**
   * Start automatic cache cleanup
   * @param intervalMs - Cleanup interval in milliseconds (default: 60000 = 1 minute)
   */
  startCacheCleanup(intervalMs: number = 60000): NodeJS.Timer {
    console.log(`[KeyVaultManager] Starting automatic cache cleanup (interval: ${intervalMs}ms)`);
    return setInterval(() => this.cleanupCache(), intervalMs);
  }
}

/**
 * Create a Key Vault manager instance
 * @param config - Key Vault configuration
 * @returns Key Vault manager
 */
export function createKeyVaultManager(config: KeyVaultConfig): KeyVaultManager {
  return new KeyVaultManager(config);
}

/**
 * Singleton Key Vault manager instance
 */
let defaultKeyVaultManager: KeyVaultManager | null = null;

/**
 * Get or create the default Key Vault manager instance
 * @param config - Key Vault configuration (required on first call)
 * @returns Key Vault manager
 */
export function getKeyVaultManager(config?: KeyVaultConfig): KeyVaultManager {
  if (!defaultKeyVaultManager) {
    if (!config) {
      throw new Error('Key Vault configuration is required for first initialization');
    }
    defaultKeyVaultManager = new KeyVaultManager(config);
  }
  return defaultKeyVaultManager;
}

/**
 * Reset the default Key Vault manager (useful for testing)
 */
export function resetKeyVaultManager(): void {
  defaultKeyVaultManager = null;
}
