/**
 * Redis-based session storage with clustering support
 * Suitable for distributed production deployments
 */

import type { ISessionStore, SessionData } from '../../types/session.js';
import { createClient, createCluster, type RedisClientType, type RedisClusterType } from 'redis';

/**
 * Redis configuration options
 */
export interface RedisConfig {
  host?: string;
  port?: number;
  password?: string;
  keyPrefix?: string;
  cluster?: boolean;
  clusterNodes?: Array<{ host: string; port: number }>;
}

/**
 * Redis-based session store with clustering support
 */
export class RedisSessionStore implements ISessionStore {
  private client: RedisClientType | RedisClusterType;
  private keyPrefix: string;
  private isConnected: boolean = false;

  /**
   * Create a new RedisSessionStore
   * @param config - Redis configuration
   */
  constructor(config: RedisConfig) {
    this.keyPrefix = config.keyPrefix || 'session:';

    if (config.cluster && config.clusterNodes && config.clusterNodes.length > 0) {
      // Create cluster client
      this.client = createCluster({
        rootNodes: config.clusterNodes.map((node) => ({
          url: `redis://${node.host}:${node.port}`,
        })),
        defaults: {
          password: config.password,
        },
      });
    } else {
      // Create standalone client
      this.client = createClient({
        socket: {
          host: config.host || 'localhost',
          port: config.port || 6379,
        },
        password: config.password,
      });
    }

    // Error handling
    this.client.on('error', (err) => {
      console.error('[RedisSessionStore] Redis error:', err);
    });

    this.client.on('connect', () => {
      console.log('[RedisSessionStore] Redis connected');
      this.isConnected = true;
    });

    this.client.on('disconnect', () => {
      console.log('[RedisSessionStore] Redis disconnected');
      this.isConnected = false;
    });

    // Connect
    this.connect();
  }

  /**
   * Connect to Redis
   */
  private async connect(): Promise<void> {
    try {
      await this.client.connect();
    } catch (error) {
      console.error('[RedisSessionStore] Connection failed:', error);
      throw new Error(`Failed to connect to Redis: ${error}`);
    }
  }

  /**
   * Ensure Redis is connected
   */
  private async ensureConnected(): Promise<void> {
    if (!this.isConnected) {
      await this.connect();
    }
  }

  /**
   * Create a new session
   * @param sessionData - Session data to store
   * @returns Session ID
   */
  async create(sessionData: SessionData): Promise<string> {
    await this.ensureConnected();

    try {
      const sessionId = sessionData.sessionId;
      const key = this.getSessionKey(sessionId);
      const userKey = this.getUserSessionKey(sessionData.userContext.userId);

      // Serialize session data
      const serialized = JSON.stringify(sessionData);

      // Calculate TTL in seconds
      const ttl = Math.floor((sessionData.expiresAt - Date.now()) / 1000);

      if (ttl <= 0) {
        throw new Error('Session already expired');
      }

      // Store session with TTL
      await this.client.setEx(key, ttl, serialized);

      // Add to user's session set
      await this.client.sAdd(userKey, sessionId);

      // Set TTL on user key (same as longest session)
      await this.client.expire(userKey, ttl);

      return sessionId;
    } catch (error) {
      console.error('[RedisSessionStore] Session creation failed:', error);
      throw new Error(`Failed to create session: ${error}`);
    }
  }

  /**
   * Get session by ID
   * @param sessionId - Session ID
   * @returns Session data or null if not found
   */
  async get(sessionId: string): Promise<SessionData | null> {
    await this.ensureConnected();

    try {
      const key = this.getSessionKey(sessionId);
      const data = await this.client.get(key);

      if (!data) {
        return null;
      }

      const session: SessionData = JSON.parse(data);

      // Redis TTL handles expiration automatically, but double-check
      if (Date.now() >= session.expiresAt) {
        await this.delete(sessionId);
        return null;
      }

      return session;
    } catch (error) {
      console.error('[RedisSessionStore] Session read failed:', error);
      throw new Error(`Failed to get session: ${error}`);
    }
  }

  /**
   * Update existing session
   * @param sessionId - Session ID
   * @param updates - Partial session data to update
   */
  async update(sessionId: string, updates: Partial<SessionData>): Promise<void> {
    await this.ensureConnected();

    try {
      const existing = await this.get(sessionId);

      if (!existing) {
        throw new Error(`Session ${sessionId} not found`);
      }

      // Merge updates
      const updated: SessionData = {
        ...existing,
        ...updates,
        userContext: updates.userContext
          ? { ...existing.userContext, ...updates.userContext }
          : existing.userContext,
        tokenMetadata: updates.tokenMetadata
          ? { ...existing.tokenMetadata, ...updates.tokenMetadata }
          : existing.tokenMetadata,
        security: updates.security
          ? { ...existing.security, ...updates.security }
          : existing.security,
      };

      const key = this.getSessionKey(sessionId);
      const serialized = JSON.stringify(updated);

      // Calculate remaining TTL
      const ttl = Math.floor((updated.expiresAt - Date.now()) / 1000);

      if (ttl > 0) {
        await this.client.setEx(key, ttl, serialized);
      }

      // Update user index if userId changed
      if (updates.userContext?.userId && updates.userContext.userId !== existing.userContext.userId) {
        const oldUserKey = this.getUserSessionKey(existing.userContext.userId);
        const newUserKey = this.getUserSessionKey(updates.userContext.userId);

        await this.client.sRem(oldUserKey, sessionId);
        await this.client.sAdd(newUserKey, sessionId);
      }
    } catch (error) {
      console.error('[RedisSessionStore] Session update failed:', error);
      throw new Error(`Failed to update session: ${error}`);
    }
  }

  /**
   * Delete session by ID
   * @param sessionId - Session ID
   */
  async delete(sessionId: string): Promise<void> {
    await this.ensureConnected();

    try {
      const session = await this.get(sessionId);

      if (session) {
        // Remove from user's session set
        const userKey = this.getUserSessionKey(session.userContext.userId);
        await this.client.sRem(userKey, sessionId);
      }

      // Delete session key
      const key = this.getSessionKey(sessionId);
      await this.client.del(key);
    } catch (error) {
      console.error('[RedisSessionStore] Session deletion failed:', error);
      throw new Error(`Failed to delete session: ${error}`);
    }
  }

  /**
   * Clean up expired sessions
   * Redis automatically expires keys with TTL, so this is mostly a no-op
   * @returns Number of sessions cleaned up (0 for Redis as TTL handles this)
   */
  async cleanup(): Promise<number> {
    // Redis handles TTL automatically, no manual cleanup needed
    return 0;
  }

  /**
   * Get all active sessions for a user
   * @param userId - User ID
   * @returns Array of session data
   */
  async getUserSessions(userId: string): Promise<SessionData[]> {
    await this.ensureConnected();

    try {
      const userKey = this.getUserSessionKey(userId);
      const sessionIds = await this.client.sMembers(userKey);

      const sessions: SessionData[] = [];

      for (const sessionId of sessionIds) {
        const session = await this.get(sessionId);
        if (session) {
          sessions.push(session);
        }
      }

      return sessions;
    } catch (error) {
      console.error('[RedisSessionStore] Get user sessions failed:', error);
      throw new Error(`Failed to get user sessions: ${error}`);
    }
  }

  /**
   * Get session count
   * Note: This scans all session keys, use sparingly in production
   * @returns Total number of active sessions
   */
  async getSessionCount(): Promise<number> {
    await this.ensureConnected();

    try {
      const pattern = `${this.keyPrefix}*`;
      let count = 0;

      // Use SCAN to avoid blocking
      for await (const key of (this.client as RedisClientType).scanIterator({ MATCH: pattern, COUNT: 100 })) {
        // Only count session keys, not user index keys
        if (!key.includes(':user:')) {
          count++;
        }
      }

      return count;
    } catch (error) {
      console.error('[RedisSessionStore] Get session count failed:', error);
      throw new Error(`Failed to get session count: ${error}`);
    }
  }

  /**
   * Get Redis session key
   * @param sessionId - Session ID
   * @returns Redis key
   */
  private getSessionKey(sessionId: string): string {
    return `${this.keyPrefix}${sessionId}`;
  }

  /**
   * Get user session index key
   * @param userId - User ID
   * @returns Redis key
   */
  private getUserSessionKey(userId: string): string {
    return `${this.keyPrefix}user:${userId}`;
  }

  /**
   * Disconnect from Redis
   */
  async disconnect(): Promise<void> {
    try {
      await this.client.quit();
      this.isConnected = false;
    } catch (error) {
      console.error('[RedisSessionStore] Disconnect failed:', error);
    }
  }

  /**
   * Check if Redis is connected
   * @returns Connection status
   */
  isRedisConnected(): boolean {
    return this.isConnected;
  }

  /**
   * Clear all sessions (for testing)
   */
  async clearAll(): Promise<void> {
    await this.ensureConnected();

    try {
      const pattern = `${this.keyPrefix}*`;

      // Use SCAN to find all keys
      for await (const key of (this.client as RedisClientType).scanIterator({ MATCH: pattern, COUNT: 100 })) {
        await this.client.del(key);
      }
    } catch (error) {
      console.error('[RedisSessionStore] Clear all failed:', error);
      throw new Error(`Failed to clear sessions: ${error}`);
    }
  }
}
